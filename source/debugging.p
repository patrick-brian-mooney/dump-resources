unit debugging;	{ This unit provides debugging routines for use when tracing through the execution of Resource Dumper. Because	}	{ it creates a debugging window that displays text using the standard Pascal writeln() function, it requires that 	}	{ the full-sized Runtime.Lib be included in the project, not one of the smaller, alternate versions.	}	{ This unit is part of Resource Dumper, which is copyright © 2018 by Patrick Mooney. program and its source	}	{ code are licensed under the GNU GPL, either version three or (at your option) any later version. See the file	}	{ LICENSE.md for details. 	}interface	uses		Aliases, Processes, AppleEvents;	procedure debuggingStartup;	procedure log_it (message: str255);{$IFC debugging}	procedure DoDebugMenuChoice (itemNo: integer);	const		{ constants for the Debug menu }		mDebug = 400;		iSendOpenAppAE = 1;		iSendOpenDocAE = 2;		iSendPrintDocAE = 3;		iSendQuitAE = 4;{$ENDC}implementation	function SelectFile (message: str255;									var selectedFIle: FSSpec): OSErr;	external;	procedure DoErrorAlert (message: str255;									errCode: OSErr);	external;	procedure debuggingStartup;{$IFC debugging}		var			theDebugMenu: MenuHandle;			textRect: rect;{$ENDC}	begin{$IFC debugging}		theDebugMenu := GetMenu(mDebug);		InsertMenu(theDebugMenu, 0);		DrawMenuBar;		setRect(textRect, 20, 50, 550, 400);		showtext;		setTextRect(textRect);{$ENDC}	end;	procedure log_it;{$IFC DEBUG_WITH_BUTTON_WAIT}		var			delayStart: longint;{$ENDC}	begin{$IFC debugging}		writeln(message);{$ENDC}{$IFC DEBUG_WITH_BUTTON_WAIT}		writeln('Press mouse button to continue...');		writeln('');		delayStart := tickCount;		repeat		until tickCount >= (delayStart + 8);		repeat		until button;		repeat		until not StillDown;{$ENDC}	end;	function getBlankAppleEvent (eventClass: AEEventClass;									eventID: AEEventID;									var theAppleEvent: AppleEvent): OSErr;		var			theErr: OSErr;			targetAddress: AEAddressDesc;			thePSN: ProcessSerialNumber;	begin		thePSN.highLongOfPSN := 0;		thePSN.lowLongOfPSN := kCurrentProcess;		theErr := AECreateDesc(typeProcessSerialNumber, @thePSN, sizeOf(thePSN), targetAddress);		if theErr <> noErr then			DoErrorAlert('Unable to create an address descriptor for the Apple Event!', theErr)		else			begin				theErr := AECreateAppleEvent(eventClass, eventID, targetAddress, kAutoGenerateReturnID, kAnyTransactionID, theAppleEvent);				if theErr <> noErr then					DoErrorAlert('Unable to create the Apple Event!', theErr);			end;		getBlankAppleEvent := theErr;	end;	procedure doSendNoParamsAE (theAEEventClass: AEEventClass;									theEventID: AEEventID);		var			theAppleEvent, reply: AppleEvent;			theErr: OSErr;	begin		theErr := getBlankAppleEvent(theAEEventClass, theEventID, theAppleEvent);		{ errors will have already been reported. }		if theErr = noErr then			begin				theErr := AESend(theAppleEvent, reply, kAENoReply + kAEALwaysInteract + kAECanSwitchLayer, kAENormalPriority, kNoTimeOut, nil, nil);				if theErr <> noErr then					DoErrorAlert('Unable to send the Apple Event!', theErr);				if AEDisposeDesc(theAppleEvent) <> noErr then					;			{IM: IAC says that the reply doesn't contain valid info because we used kAENoReply, so don't attempt to dispose of it. }			end;	end;	procedure doSendOpenAppAE;	{ Send an Open Application Apple Event to ourselves. }	begin		log_it('Chose to send an Open App AE!');		doSendNoParamsAE(kCoreEventClass, kAEOpenApplication);	end;	procedure doSendQuitAE;	begin		log_it('Chose to send a Quit AE!');		doSendNoParamsAE(kCoreEventClass, kAEQuitApplication);	end;	procedure doSendOneParamAE (theAEEventClass: AEEventClass;									theEventID: AEEventID);		var			err: OSErr;			theAppleEvent, reply: AppleEvent;			targetFile: FSSpec;			targetFileDesc: AEDesc;			targetAlias: aliasHandle;	begin		targetAlias := nil;		err := SelectFile('Which file does the event concern?', targetFile);		if (err <> noErr) and (err <> userCanceledErr) then			DoErrorAlert('Unable to choose a file to attach to the event!', err);		if err = noErr then			begin				err := getBlankAppleEvent(theAEEventClass, theEventID, theAppleEvent);				if err <> noErr then					DoErrorAlert('Unable to create a blank Apple Event!', err)				else					log_it('Successfully created a blank Apple Event!');			end;		if err = noErr then			begin				err := NewAlias(nil, targetFile, targetAlias);				if err <> noErr then					DoErrorAlert('Unable to create a reference to the file!', err)				else					log_it('Created a reference to the file!');			end;		if err = noErr then			begin				HLockHi(handle(targetAlias));				err := AECreateDesc(typeAlias, targetAlias^, getHandleSize(handle(targetAlias)), targetFileDesc);				if err <> noErr then					DoErrorAlert('Unable to create a descriptor from the file reference!', err)				else					log_it('Created a descriptor from file reference!');			end;		if err = noErr then			begin				err := AEPutParamDesc(theAppleEvent, keyDirectObject, targetFileDesc);				if err <> noErr then					DoErrorAlert('Unable to attach the file descriptor to the Apple Event!', err)				else					log_it('Attached the file descriptor to the Apple Event!');			end;		if err = noErr then			begin				err := AESend(theAppleEvent, reply, kAENoReply, kAENormalPriority, kAEDefaultTimeout, nil, nil);				if err <> noErr then					DoErrorAlert('Unable to send the Apple Event!', err)				else					log_it('Successfully sent the Apple Event!');			end;		if targetAlias <> nil then			DisposeHandle(Handle(targetAlias));		if AEDisposeDesc(targetFileDesc) <> noErr then			;		if AEDisposeDesc(theAppleEvent) <> noErr then			;		if AEDisposeDesc(targetFileDesc) <> noErr then			;	end;	procedure doSendOpenDocAE;		var			err: OSErr;			theAppleEvent, reply: AppleEvent;			targetFile: FSSpec;			targetFileDesc: AEDesc;			targetAlias: aliasHandle;	begin		log_it('Chose to send an Open Doc AE!');		doSendOneParamAE(kCoreEventClass, kAEOpenDocuments);	end;	procedure doSendPrintDocAE;	begin		log_it('Chose to send a Print Doc AE!');		doSendOneParamAE(kCoreEventClass, kAEPrintDocuments);	end;	procedure DoDebugMenuChoice (itemNo: integer);	begin{$IFC debugging}		case itemNo of			iSendOpenAppAE: 				doSendOpenAppAE;			iSendOpenDocAE: 				doSendOpenDocAE;			iSendPrintDocAE: 				doSendPrintDocAE;			iSendQuitAE: 				doSendQuitAE;			otherwise				;		end;{$ENDC}	end;end.