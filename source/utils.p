unit utils;interface	{ A bunch of utility code for Resource Dumper. }	{ This unit is part of Resource Dumper, which is copyright © 2018 by Patrick Mooney. program and its source	}	{ code are licensed under the GNU GPL, either version three or (at your option) any later version. See the file	}	{ LICENSE.md for details. 	}	uses		traps, AppleEvents, EPPC;	const		rMBarID = 128;		mApple = 128;		iAbout = 1;		mDump = 129;		iChangeResourceTypes = 1;		iDumpToData = 2;		iQuit = 4;		mEdit = 130;		iUndo = 1;		iCut = 3;		iCopy = 4;		iPaste = 5;		iClear = 7;		iOK = 1;							{ used by many dialogs }		iCancel = 2;		rAboutBoxALRT = 128;		rGenericErrorALRT = 1000;		rInformationalMessageALRT = 1001;		rWarningALRT = 1002;		rDumpToFilesDLOG = 2001;	{ iOK and iCancel, too, of course }		iButtonOutline = 3;		iResTypeField = 4;		iLowestIDField = 5;		iHighestIDField = 6;		iOutputFileTypeField = 7;		iOutputFileCreatorField = 8;		rRetypeResourceDLOG = 2002;	{ also iOK, iCancel, and iButtonOutline }		iOriginalTypeField = 4;		iNewTypeField = 5;		kEnter = char(3);		kReturn = char(13);		kEscape = char(27);		kPeriod = '.';	var		gFinished: boolean;		gHasWNE: boolean;					{ Do we have _WaitNextEvent? }		gHasHLE: boolean;						{ ... high-level events? }		gHasAE: boolean;						{ ... Apple Events? }		gHasFSSpec: boolean;					{ ... FSSpec-based File Manager calls? }	function NumFromString (theString: str255): longint;	function StringFromNum (theNum: longint): str255;	function GetResourceID (theResource: handle): integer;	function TrapAvailable (theTrap: Integer): Boolean;	function FSSpecRoutinesAvail: boolean;	procedure doAdjustMenus;	procedure doUpdate (theWindow: univ windowPtr);	procedure DoDisk (eventMessage: longint);	function MyGotRequiredParams (theAppleEvent: AppleEvent): OSErr;	function standardFilter (theDialog: DialogPtr;									var theEvent: EventRecord;									var itemHit: integer): boolean;	procedure DrawDefaultButtonOutline (theDialog: DialogPtr;									itemNo: integer);	function getDItemText (theDialog: dialogPtr;									itemNo: integer): str255;	procedure setUserItemDrawProc (theDialog: dialogPtr;									itemNo: integer;									drawProc: procPtr);	function SelectFile (message: str255;									var selectedFIle: FSSpec): OSErr;	function SelectSaveLocation (message: str255;									var selectedFile: FSSpec): OSErr;	procedure DoErrorAlert (message: str255;									errCode: OSErr);	procedure DisplayInformationalAlert (message: str255);	procedure DoWarningAlert (message: str255;									errCode: OSErr);implementation	function UnivFSMakeFSSpec (realVRefNum: integer;									realDirID: longint;									fName: str63;									selectedFile: FSSpec): OSErr;	external;	function FSSpecRoutinesAvail: boolean;	{ more or less straight from IM: Files 1-14. }		var			theErr: OSErr;			theFeature: longint;	begin		FSSpecRoutinesAvail := false;		if trapAvailable(_Gestalt) then			begin				theErr := Gestalt(gestaltFSAttr, theFeature);				if theErr = noErr then					if BTst(theFeature, gestaltHasFSSpecCalls) then						FSSpecRoutinesAvail := true;			end;	end;	function MyGotRequiredParams (theAppleEvent: AppleEvent): OSErr;	{ Straight from IM: Interapplication Communication 4-35 }		var			theErr: OSErr;			returnedType: DescType;			actualSize: Size;	begin		theErr := AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr, typeWildCard, returnedType, nil, 0, actualSize);		if theErr = errAEDescNotFound then			MyGotRequiredParams := noErr		else if theErr = noErr then			MyGotRequiredParams := errAEparamMissed		else			MyGotRequiredParams := theErr;	end;	procedure doXAbleMItem (menuID, itemNo: integer;									enable: boolean);		var			theMHandle: MenuHandle;	begin		theMHandle := GetMenuHandle(menuID);		if enable then			EnableItem(theMHandle, itemNo)		else			DisableItem(theMHandle, itemNo);	end;	procedure doAdjustMenus;	begin		if FrontWindow = nil then									{ The normal situation for us }			begin				doXAbleMItem(mEdit, 0, false);									{ We don't use the edit menu, ourselves }				doXAbleMItem(mDump, 0, true);				doXAbleMItem(mApple, 0, true);			end		else if WindowPeek(FrontWindow)^.windowKind < 0 then			{ DA window is frontmost (and we're pre-system 7) }			begin				doXAbleMItem(mEdit, 0, true);									{ The DA may need the Edit menu, which is really the main reason we have it }				doXAbleMItem(mEdit, iUndo, true);								{ iUndo is the only item we ever touch ourselves. }				doXAbleMItem(mDump, 0, true);				doXAbleMItem(mApple, 0, true);			end		else if WindowPeek(FrontWindow)^.windowKind = DialogKind then	{ It's one of our modal dialg windows }			begin				doXAbleMItem(mEdit, 0, true);				doXAbleMItem(mEdit, iUndo, false);				doXAbleMItem(mDump, 0, false);				doXAbleMItem(mApple, 0, false);			end;		DrawMenuBar;	end;	function NumFromString (theString: str255): longint;		var			return: longint;	begin		StringToNum(theString, return);		NumFromString := return;	end;	function StringFromNum (theNum: longint): str255;		var			return: str255;	begin		NumToString(theNum, return);		StringFromNum := return;	end;{$PUSH}{$Z+}	procedure DoErrorAlert (message: str255;									errCode: OSErr);	begin		ParamText(message, StringFromNum(errCode), '', '');		if alert(rGenericErrorALRT, nil) <> noErr then			;	end;{$POP}	procedure DisplayInformationalAlert (message: str255);	begin		ParamText(message, '', '', '');		if alert(rInformationalMessageALRT, nil) <> noErr then			;	end;	procedure DoWarningAlert (message: str255;									errCode: OSErr);	begin		ParamText(message, StringFromNum(errCode), '', '');		if alert(rWarningALRT, nil) <> noErr then			;	end;	procedure DoDisk (eventMessage: longint);		var			thePoint: Point;			theErr: OSErr;	begin		if (HiWord(eventMessage) <> noErr) then			begin				SetPt(thePoint, 120, 120);				theErr := DIBadMount(thePoint, eventMessage);			end	end;	function TrapAvailable (theTrap: Integer): Boolean;	{ Thx to the THINK Class Library for this one. }		var			tType: TrapType;			numToolBoxTraps: Integer;	begin		if BAND(theTrap, $0800) > 0 then		{ first determine the trap type }			tType := ToolTrap		else			tType := OSTrap;							{ next find out how may traps there are }		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			numToolBoxTraps := $200		else			numToolBoxTraps := $400;		if tType = ToolTrap then 					{ check if trap number is too big for current trap table }			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= numToolBoxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := (NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap));	end;	function GetResourceID (theResource: handle): integer;		var			theID: integer;			theType: ResType;			name: str255;	begin		GetResInfo(theResource, theID, theType, name);		GetResourceID := theID;	end;	procedure doUpdate (theWindow: univ windowPtr);			{ any window this app has to update is a dialog window. }		var			oldPort: grafPtr;	begin		if theWindow <> nil then			{ it's unlikely that we'll be passed a null pointer for an updateEvt, but ... }			begin				getPort(oldPort);				setPort(theWindow);				BeginUpdate(theWindow);				if not (EmptyRgn(theWindow^.visRgn)) then					begin						EraseRgn(theWindow^.visRgn);						drawDialog(theWindow);					end;				EndUpdate(theWindow);				setPort(oldPort);			end;	end;	function getDItemHandle (theDialog: dialogPtr;									itemNo: integer): handle;		var			itemType: integer;			itemHandle: handle;			itemRect: rect;	begin		getDItem(theDialog, itemNo, itemType, itemHandle, itemRect);		getDItemHandle := itemHandle;	end;	function getDItemText (theDialog: dialogPtr;									itemNo: integer): str255;		var			tempString: str255;	begin		getIText(getDItemHandle(theDialog, itemNo), tempString);		getDItemText := tempString;	end;	function getDItemControlHandle (theDialog: dialogPtr;									itemNo: integer): controlHandle;	begin		getDItemControlHandle := controlHandle(GetDItemHandle(theDialog, itemNo));	end;	procedure setUserItemDrawProc (theDialog: dialogPtr;									itemNo: integer;									drawProc: procPtr);		var			itemType: integer;			itemHandle: handle;			itemRect: rect;	begin		getDItem(theDialog, itemNo, itemType, itemHandle, itemRect);		setDItem(theDialog, itemNo, itemType, handle(drawProc), itemRect);	end;	procedure DoOutlineControl (theControl: univ ControlHandle);		var			theOval: integer;			theRect: Rect;			origPen: PenState;			origPort: grafPtr;	begin		if theControl <> nil then			begin				getPort(origPort);				setPort(theControl^^.contrlOwner);				getPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				insetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = 0) then					PenPat(black)				else					PenPat(gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				setPenState(origPen);				setPort(origPort);			end;	end;	procedure DrawDefaultButtonOutline (theDialog: DialogPtr;									itemNo: integer);		var			theType: integer;			theHand: handle;			therect: rect;	begin		GetDialogItem(theDialog, iOK, theType, theHand, theRect);		DoOutlineControl(theHand);	end;	procedure handleMenuChoice (menuChoice: longint);	external;	function standardFilter (theDialog: DialogPtr;									var theEvent: EventRecord;									var itemHit: integer): boolean;		var			charCode: char;			itemType: integer;			itemHandle: Handle;			itemRect: Rect;			finalTicks: longint;			handledEvent: boolean;			thePoint: Point;			theErr: OSErr;			partCode: integer;			theWindow: windowPtr;	begin		handledEvent := false;		case (theEvent.what) of			keyDown, autoKey: 				begin					charCode := chr(BAnd(theEvent.message, charCodeMask));					if ((charCode = char(kReturn)) or (charCode = char(kEnter))) then						begin							GetDItem(theDialog, iOK, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), inButton);							Delay(8, finalTicks);							HiliteControl(ControlHandle(itemHandle), 0);							handledEvent := true;							itemHit := iOK;						end;					if ((charCode = char(kEscape)) or ((BAnd(theEvent.modifiers, cmdKey) <> 0) and (charCode = char(kPeriod)))) then						begin							HiliteControl(getDItemControlHandle(theDialog, iCancel), inButton);							Delay(8, finalTicks);							HiliteControl(getDItemControlHandle(theDialog, iCancel), 0);							handledEvent := true;							itemHit := iCancel;						end;				end;			diskEvt: 				begin					DoDisk(theEvent.message);					handledEvent := true;				end;			updateEvt: 				doUpdate(theEvent.message);			mouseDown: 				begin					partCode := FindWindow(theEvent.where, theWindow);					case partcode of						inSysWindow: 							SystemClick(theEvent, theWindow);						inDrag: 							begin								DragWindow(theWindow, theEvent.where, screenBits.bounds);								handledEvent := true;							end;						inMenuBar: 							HandleMenuChoice(MenuSelect(theEvent.where));						inContent: 							if theWindow <> theDialog then								sysbeep(1);						otherwise							;					end;				end;			otherwise				;		end;		standardFilter := handledEvent;	end;{$PUSH}{$Z+}	function SelectFile (message: str255;									var selectedFIle: FSSpec): OSErr;		var			theReply: SFReply;			where: point;			typeList: SFTypeList;			err: OSErr;			realVRefNum: integer;			realDirID, disposableLongint: longint;	begin		SetPt(where, 40, 40);		SFGetFile(where, message, nil, -1, @typeList, nil, theReply);		if not theReply.good then			{ user canceled }			SelectFile := userCanceledErr		else			begin				err := GetWDInfo(theReply.vRefNum, realVRefNum, realDirID, disposableLongint);				if err <> noErr then					DoErrorAlert('Unable to convert a working directory reference number!', err);				if err = noErr then					begin						err := UnivFSMakeFSSpec(realVRefNum, realDirID, theReply.fName, selectedFile);						if err <> noErr then			{ Christ, fill it in manually if all else fails. }							with selectedFile do								begin									vRefNum := realVRefNum;									parID := realDirID;									name := theReply.fName;								end;						err := noErr;					end;				SelectFile := err;			end;	end;{$POP}	function SelectSaveLocation (message: str255;									var selectedFile: FSSpec): OSErr;		var			where: point;			theReply: SFReply;			err: OSErr;			realVRefNum: integer;			realDirID, disposableLongint: longint;	begin		SetPt(where, 40, 40);		SFPutFile(where, message, '', nil, theReply);		if theReply.good then			begin				err := GetWDInfo(theReply.vRefNum, realVRefNum, realDirID, disposableLongint);				if err <> noErr then					DoErrorAlert('Unable to convert a working directory reference number !', err);				err := FSMakeFSSpec(realVRefNum, realDirID, theReply.fName, selectedFile);				if err <> noErr then			{ Christ, fill it in manually if all else fails. }					begin						with selectedFile do							begin								vRefNum := realVRefNum;								parID := realDirID;								name := theReply.fName;							end;						err := noErr;					end;				if (err <> noErr) and (err <> fnfErr) then					begin						DoErrorAlert('Unable to create a file specification record!', err);						SelectSaveLocation := err;					end				else					SelectSaveLocation := noErr;			end		else			SelectSaveLocation := userCanceledErr;	end;end.