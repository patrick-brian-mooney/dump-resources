unit utils;interface	uses		traps, FSpCompat;	const		rMBarID = 128;		mApple = 128;		iAbout = 1;		mDump = 129;		iChangeResourceTypes = 1;		iDumpToData = 2;		iQuit = 4;		mEdit = 130;		iUndo = 1;		iCut = 3;		iCopy = 4;		iPaste = 5;		iSelectAll = 7;		iOK = 1;							{ used by many dialogs }		iCancel = 2;		rAboutBoxALRT = 128;		rGenericErrorALRT = 1000;		rInformationalMessageALRT = 1001;		rDumpToFilesDLOG = 2001;	{ iOK and iCancel, too, of course }		iButtonOutline = 3;		iResTypeField = 4;		iLowestIDField = 5;		iHighestIDField = 6;		iOutputFileTypeField = 7;		iOutputFileCreatorField = 8;		rRetypeResourceDLOG = 2002;	{ also iOK, iCancel, and iButtonOutline }		iOriginalTypeField = 4;		iNewTypeField = 5;		kEnter = char(3);		kReturn = char(13);		kEscape = char(27);		kPeriod = '.';	function NumFromString (theString: str255): longint;	function StringFromNum (theNum: longint): str255;	function GetResourceID (theResource: handle): integer;	function TrapAvailable (theTrap: Integer): Boolean;	procedure doUpdate (theWindow: univ windowPtr);	procedure DrawDefaultButtonOutline (theDialog: DialogPtr);	function getDItemText (theDialog: dialogPtr;									itemNo: integer): str255;	function SelectFileToDump (message: str255;									var selectedFIle: FSSpec): OSErr;	function SelectSaveLocation (message: str255;									var selectedFile: FSSpec): OSErr;	procedure DoErrorAlert (message: str255;									errCode: OSErr);	procedure DisplayInformationalAlert (message: str255);implementation	function NumFromString (theString: str255): longint;		var			return: longint;	begin		StringToNum(theString, return);		NumFromString := return;	end;	function StringFromNum (theNum: longint): str255;		var			return: str255;	begin		NumToString(theNum, return);		StringFromNum := return;	end;	function GetResourceID (theResource: handle): integer;		var			theID: integer;			theType: ResType;			name: str255;	begin		GetResInfo(theResource, theID, theType, name);		GetResourceID := theID;	end;	function ModalDialogFilter: boolean;  			{ #FIXME: not even the parameter list is correct! }	begin																{ #FIXME: nothing calls this routine! }	end;	function TrapAvailable (theTrap: Integer): Boolean;	{ Thx to the THINK Class Library for this one. }		var			tType: TrapType;			numToolBoxTraps: Integer;	begin		if BAND(theTrap, $0800) > 0 then		{ first determine the trap type }			tType := ToolTrap		else			tType := OSTrap;							{ next find out how may traps there are }		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			numToolBoxTraps := $200		else			numToolBoxTraps := $400;		if tType = ToolTrap then 					{ check if trap number is too big for current trap table }			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= numToolBoxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := (NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap));	end;	procedure doUpdate (theWindow: univ windowPtr);			{ any window this app has to update is a dialog window. }		var			oldPort: grafPtr;	begin		if theWindow <> nil then			{ it's unlikely that we'll be passed a null pointer for an updateEvt, but ... }			begin				getPort(oldPort);				setPort(theWindow);				BeginUpdate(theWindow);				if not (EmptyRgn(theWindow^.visRgn)) then					begin						EraseRgn(theWindow^.visRgn);						drawDialog(theWindow);					end;				EndUpdate(theWindow);				setPort(oldPort);			end;	end;	function getDItemHandle (theDialog: dialogPtr;									itemNo: integer): handle;		var			itemType: integer;			itemHandle: handle;			itemRect: rect;	begin		getDItem(theDialog, itemNo, itemType, itemHandle, itemRect);		getDItemHandle := itemHandle;	end;	function getDItemText (theDialog: dialogPtr;									itemNo: integer): str255;		var			tempString: str255;	begin		getIText(getDItemHandle(theDialog, itemNo), tempString);		getDItemText := tempString;	end;	procedure DoOutlineControl (theControl: univ ControlHandle);		var			theOval: integer;			theRect: Rect;			origPen: PenState;			origPort: grafPtr;	begin		if theControl <> nil then			begin				getPort(origPort);				setPort(theControl^^.contrlOwner);				getPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				insetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = 0) then					PenPat(black)				else					PenPat(gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				setPenState(origPen);				setPort(origPort);			end;	end;	procedure DrawDefaultButtonOutline (theDialog: DialogPtr);		var			theType: integer;			theHand: handle;			therect: rect;	begin		GetDialogItem(theDialog, iOK, theType, theHand, theRect);		DoOutlineControl(theHand);	end;	function SelectFileToDump (message: str255;									var selectedFIle: FSSpec): OSErr;		var			theReply: SFReply;			where: point;			typeList: SFTypeList;			err: OSErr;	begin		SetPt(where, 40, 40);		SFGetFile(where, '', nil, -1, @typeList, nil, theReply);		if theReply.good then			{ otherwise, user canceled }			begin	{ #FIXME: we need to actually convert the wdRefNum into a real vol/dir ID pair, I think }				err := FSMakeFSSpecCompat(theReply.vRefNum, 0, theReply.fName, selectedFile);				SelectFileToDump := err;				if err <> noErr then					DoErrorAlert('Unable to create a file specification record!', err);			end		else			SelectFileToDump := userCanceledErr;	end;	function SelectSaveLocation (message: str255;									var selectedFile: FSSpec): OSErr;		var			where: point;			theReply: SFReply;			err: OSErr;	begin		SetPt(where, 40, 40);		SFPutFile(where, message, '', nil, theReply);		if theReply.good then			begin				err := FSMakeFSSpecCompat(theReply.vRefNum, 0, theReply.fName, selectedFile);				if (err <> noErr) and (err <> fnfErr) then					begin						DoErrorAlert('Unable to create a file specification record!', err);						SelectSaveLocation := err;					end				else					SelectSaveLocation := noErr;			end		else			SelectSaveLocation := userCanceledErr;	end;	procedure DoAlert (alertID: integer;									message: str255);	begin		ParamText(message, '', '', '');		if alert(alertID, nil) <> noErr then			;	end;	procedure DoErrorAlert (message: str255;									errCode: OSErr);		var			errString: str255;	begin		NumToString(errCode, errString);		ParamText(message, errString, '', '');		if alert(rGenericErrorALRT, nil) <> noErr then			;	end;	procedure DisplayInformationalAlert (message: str255);	begin		ParamText(message, '', '', '');		if alert(rInformationalMessageALRT, nil) <> noErr then			;	end;end.