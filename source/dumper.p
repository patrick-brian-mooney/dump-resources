program dumper;	uses		traps, 								{ Listing ToolBox units first... }		debugging, utils, resHandling;	procedure DoAboutBox;	begin		if alert(rAboutBoxALRT, nil) <> 0 then			;	end;	procedure doAppleMenuChoice (itemNo: integer);		var			itemName: str255;			daDriverRefNum: integer;			oldPort: grafPtr;	begin		case itemNo of			iAbout: 				doAboutBox;			otherwise				begin					GetItem(getMHandle(mApple), itemNo, itemName);					GetPort(oldPort);									{ Work around problems with some VERY old software }					daDriverRefNum := OpenDeskAcc(itemName);					SetPort(oldPort);				end;		end;	end;	procedure DoDumpMenuChoice (itemNo: integer);	begin		case itemNo of			iDumpToData: 				DumpToFiles;			iChangeResourceTypes: 				ChangeToNewResType;			iQuit: 				gFinished := true;		end;	end;	procedure DoEditMenuChoice (itemNo: integer);	{ All windows we deal with are either modal dialogs or, under pre-sys 7, desk accessory windows }	begin		if not systemEdit(itemNo - 1) then		{ If it's not handled by a DA ... }			if frontWindow <> nil then				begin					case itemNo of						iUndo: 							sysBeep(0);			{ But then, we never enable this. It's just there for DAs that expect it. }						iCut: 							DialogCut(FrontWindow);						iCopy: 							DialogCopy(FrontWindow);						iPaste: 							DialogPaste(FrontWindow);						iClear: 							DialogDelete(FrontWindow);					end;				end;	end;	procedure DoHighLevelEvent (theEvent: eventRecord);		var			theErr: OSErr;	begin		log_it(concat('We got a high-level event! It has class ', OSType(theEvent.message), ' and ID ', OSType(theEvent.where)));		theErr := AEProcessAppleEvent(theEvent);		if theErr <> noErr then			DoErrorAlert('Could not process an Apple Event that we received!', theErr);	end;{$PUSH}{$Z+}	procedure handleMenuChoice (menuChoice: longint);	begin		if menuChoice <> 0 then			case (HiWord(menuChoice)) of				mApple: 					DoAppleMenuChoice(LoWord(menuChoice));				mDump: 					DoDumpMenuChoice(LoWord(menuChoice));				mEdit: 					DoEditMenuChoice(LoWord(menuChoice));{$IFC debugging}				mDebug: 					DoDebugMenuChoice(LoWord(menuChoice));{$ENDC}				otherwise					;			end;	end;{$POP}	function eventGetter (eventMask: integer;									var theEvent: EventRecord): boolean;	begin		if gHasWNE then			eventGetter := WaitNextEvent(eventMask, theEvent, 8, nil)		else			begin				eventGetter := GetNextEvent(eventMask, theEvent);				SystemTask;			end;	end;	procedure mainLoop;		var			theEvent: EventRecord;			partCode: integer;			theWindow: WindowPtr;			menuChoice: longint;	begin		repeat			hiliteMenu(0);			if eventGetter(everyEvent, theEvent) then				begin					case theEvent.what of						updateEvt: 							doUpdate(theEvent.message);						keyDown: 							if (BAnd(theEvent.modifiers, cmdKey) <> 0) then								HandleMenuChoice(MenuKey(CHR(BAnd(theEvent.message, charCodeMask))));						mouseDown: 							begin								doAdjustMenus;								partCode := FindWindow(theEvent.where, theWindow);								case partCode of									inSysWindow: 										SystemClick(theEvent, theWindow);									inContent: 										if (theWindow <> FrontWindow) then											SelectWindow(theWindow);									inDrag: 										DragWindow(theWindow, theEvent.where, screenBits.bounds);									inMenuBar: 										begin						{#FIXME: adjust menus }											menuChoice := MenuSelect(theEvent.where);											if menuChoice <> 0 then												HandleMenuChoice(menuChoice);										end;									diskEvt: 										DoDisk(theEvent.message);									otherwise										;								end;							end;						kHighLevelEvent: 							DoHighLevelEvent(theEvent);						otherwise							;					end;				end;		until gFinished;		;	end;	function DoHandleOpenAppEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;	begin		log_it('Handling the Open App event!');		DoHandleOpenAppEvent := MyGotRequiredParams(theAppleEvent);		{ Why is it again that the OS announces to us that we're running? }	end;	function DoHandleOpenDocEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;		var			theFSS: FSSpec;			docList: AEDescList;			theErr: OSErr;			index, itemsInList: longint;			actualSize: size;			keywd: AEKeyword;			returnedType: DescType;	begin		log_it('Handling the Open Documents event!');	{ First, get the list of files we're being asked to deal with. }		theErr := AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);		if theErr <> noErr then			DoErrorAlert('Unable to decode the Apple Event parameters ', theErr);		if theErr = noErr then			begin				theErr := MyGotRequiredParams(theAppleEvent);				if theErr <> noErr then					DoErrorAlert('Failed to retrieve all mandatory Apple Event parameters!', theErr);			end;		if theErr = noErr then			begin				theErr := AECountItems(docList, itemsInList);				if theErr <> noErr then					DoErrorAlert('Unable to count the number of documents we should deal with', theErr)				else					for index := 1 to itemsInList do						begin							theErr := AEGetNthPtr(doclist, index, typeFSS, keywd, returnedType, @theFSS, sizeof(theFSS), actualsize);							if theErr <> noErr then								DoErrorAlert('Unable to decode a reference to a file', theErr)							else								begin									paramText(theFSS.name, '', '', '');									if alert(rDumpOrReTypeAlert, @StandardFilter) = iDump then										DumpFileToFiles(theFSS)									else										ChangeFileToNewResType(theFSS);								end;						end;				if AEDisposeDesc(docList) <> noErr then					;			end;		DoHandleOpenDocEvent := theErr;	end;	function DoHandlePrintDocEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;		var			theFSS: FSSpec;			docList: AEDescList;			theErr: OSErr;			index, itemsinList: longint;			actualSize: Size;			keywd: AEKeyword;			returnedType: DescType;	begin		log_it('Handling the Print Documents event!');		theErr := AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);		if theErr <> noErr then			DoErrorAlert('Unable to get the file list!', theErr)		else			begin				theErr := MyGotRequiredParams(theAppleEvent);				if theErr <> noErr then					DoErrorAlert('Did not retrieve all required parameters from the Apple Event!', theErr);			end;		if theErr = noErr then			begin				theErr := AECountItems(docList, itemsInList);				if theErr <> noErr then					DoErrorAlert('Unable to count items in the file list!', theErr)				else					begin						for index := 1 to itemsInList do							begin								theErr := AEGetNthPtr(docList, index, typeFSS, keywd, returnedType, @theFSS, sizeof(theFSS), actualSize);								if theErr <> noErr then									DoErrorAlert('Unable to retrieve a file from the Apple Event!', theErr)								else									DoErrorAlert(concat('Resource Dumper is unable to print ', theFSS.name, ' because Resource Dumper cannot print documents!'), noErr);							end;						if AEDisposeDesc(docList) <> noErr then							;					end;			end;		DoHandlePrintDocEvent := theErr;	end;	function DoHandleQuit (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;	begin		log_it('Handling the Quit event!');		gFinished := True;		DoHandleQuit := MyGotRequiredParams(theAppleEvent);	end;	procedure setupAEHandlers;		var			theErr: OSErr;	begin		theErr := AEinstallEventHandler(kCoreEventClass, kAEOpenApplication, @DoHandleOpenAppEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, @DoHandleOpenDocEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, @DoHandlePrintDocEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, @DoHandleQuit, 0, False);		if theErr <> noErr then			DoErrorAlert('Unable to set up Apple Event handlers!', theErr)		else			log_it('Successfully installed all Apple Event Handlers!');	end;	procedure toolBoxInit;	begin		InitCursor;		FlushEvents(everyEvent, 0);	end;	procedure setupUI;		var			menubarHdl: handle;	begin		menubarHdl := GetNewMBar(rMBarID);		if (menubarHdl <> nil) then			begin				SetMenuBar(menubarHdl);				AddResMenu(GetMHandle(mApple), 'DRVR');				DrawMenuBar;			end		else			begin				DoErrorAlert('Unable to set up the application menu bar!', resError);				exitToShell;			end;	end;	function GestaltHasHLE: boolean;	{ Assumes we at least have the Gestalt Manager }		var			err1, err2: OSErr;			response1, response2: longint;	begin		gestaltHasHLE := False;		err1 := Gestalt(gestaltPPCToolboxAttr, response1);		err2 := Gestalt(gestaltOSAttr, response2);		if (err1 = noErr) and (err2 = noErr) then	{ skip testing gestaltPPCToolboxPresent in response1: it's just a $0000 mask. Assuming noErr on the _gestalt response means it's present. Great fuckin' design there, Apple. Good job saving 28 bits that were never used. }			gestaltHasHLE := BTst(response2, gestaltLaunchControl);	end;	function GestaltHasAE: boolean;	{ Assumes the Gestalt Manager is present }		var			theErr: OSErr;			response: longint;	begin		GestaltHasAE := False;		theErr := Gestalt(gestaltAppleEventsAttr, response);		if theErr = noErr then			GestaltHasAE := BTst(response, gestaltAppleEventsPresent);	end;	procedure initProgram;	begin		toolboxInit;		setupUI;		debuggingStartup;		gFinished := false;		gHasWNE := trapAvailable(_WaitNextEvent);		if trapAvailable(_Gestalt) then			begin				gHasHLE := GestaltHasHLE;				if gHasHLE then					gHasAE := GestaltHasAE;			end		else			begin				gHasHLE := False;				gHasAE := False;			end;		if gHasAE then			setupAEHandlers;	end;begin	initProgram;	log_it('Setup complete!');	mainLoop;	log_it('Main loop exited!');{$IFC debugging}	log_it('press mouse button to exit');	repeat	until button;{$ENDC}	exitToShell;end.