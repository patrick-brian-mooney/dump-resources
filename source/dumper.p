program dumper;	uses		traps, 						{ Listing ToolBox units first. }		utils, resHandling;	var		gFinished: boolean;		gHasWNE: boolean;	procedure DoAboutBox;	begin		if alert(rAboutBoxALRT, nil) <> 0 then			;	end;	procedure doAppleMenuChoice (itemNo: integer);		var			itemName: str255;			daDriverRefNum: integer;			oldPort: grafPtr;	begin		case itemNo of			iAbout: 				doAboutBox;			otherwise				begin					GetItem(getMHandle(mApple), itemNo, itemName);					GetPort(oldPort);									{ Work around problems with some VERY old software }					daDriverRefNum := OpenDeskAcc(itemName);					SetPort(oldPort);				end;		end;	end;	procedure DoDumpMenuChoice (itemNo: integer);	begin		case itemNo of			iDumpToData: 				DumpToFiles;			iChangeResourceTypes: 				ChangeToNewResType;			iQuit: 				gFinished := true;		end;	end;	procedure doEditMenuChoice (itemNo: integer);	{ All windows we deal with are either modal dialogs or, under pre-sys 7, desk accessory windows }	begin		if not systemEdit(itemNo - 1) then		{ If it's not handled by a DA ... }			if frontWindow <> nil then				begin					case itemNo of						iUndo: 							sysBeep(0);			{ But then, we never enable this. It's just there for DAs that expect it. }						iCut: 							DialogCut(FrontWindow);						iCopy: 							DialogCopy(FrontWindow);						iPaste: 							DialogPaste(FrontWindow);						iClear: 							DialogDelete(FrontWindow);					end;				end;	end;{$PUSH}{$Z+}	procedure handleMenuChoice (menuChoice: longint);	begin		if menuChoice <> 0 then			case (HiWord(menuChoice)) of				mApple: 					doAppleMenuChoice(LoWord(menuChoice));				mDump: 					doDumpMenuChoice(LoWord(menuChoice));				mEdit: 					doEditMenuChoice(LoWord(menuChoice));				otherwise					;			end;	end;{$POP}	function eventGetter (eventMask: integer;									var theEvent: EventRecord): boolean;	begin		if gHasWNE then			eventGetter := WaitNextEvent(eventMask, theEvent, 8, nil)		else			begin				eventGetter := GetNextEvent(eventMask, theEvent);				SystemTask;			end;	end;	procedure mainLoop;		var			theEvent: EventRecord;			partCode: integer;			theWindow: WindowPtr;			menuChoice: longint;	begin		repeat			hiliteMenu(0);			if eventGetter(everyEvent, theEvent) then				begin					case theEvent.what of						updateEvt: 							doUpdate(theEvent.message);						keyDown: 							if (BAnd(theEvent.modifiers, cmdKey) <> 0) then								HandleMenuChoice(MenuKey(CHR(BAnd(theEvent.message, charCodeMask))));						mouseDown: 							begin								doAdjustMenus;								partCode := FindWindow(theEvent.where, theWindow);								case partCode of									inSysWindow: 										SystemClick(theEvent, theWindow);									inContent: 										if (theWindow <> FrontWindow) then											SelectWindow(theWindow);									inDrag: 										DragWindow(theWindow, theEvent.where, screenBits.bounds);									inMenuBar: 										begin											menuChoice := MenuSelect(theEvent.where);											if menuChoice <> 0 then												HandleMenuChoice(menuChoice);										end;									diskEvt: 										DoDisk(theEvent.message);									otherwise										;								end;							end;						otherwise							;					end;				end;		until gFinished;		;	end;	procedure toolBoxInit;	begin		InitCursor;		FlushEvents(everyEvent, 0);	end;	procedure setupUI;		var			menubarHdl: handle;	begin		menubarHdl := GetNewMBar(rMBarID);		if (menubarHdl <> nil) then			begin				SetMenuBar(menubarHdl);				AddResMenu(GetMHandle(mApple), 'DRVR');				DrawMenuBar;			end;	end;	procedure initProgram;	begin		toolboxInit;		setupUI;		gFinished := false;		gHasWNE := trapAvailable(_WaitNextEvent);	end;begin	initProgram;{$IFC DEBUGGING}	DisplayInformationalAlert('Setup complete!');{$ENDC}	mainLoop;{$IFC DEBUGGING}	DisplayInformationalAlert('Main loop exited!');{$ENDC}end.