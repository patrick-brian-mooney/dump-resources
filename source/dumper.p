program dumper;	uses		traps, AppleEvents, EPPC,				{ Listing ToolBox units first. }		utils, resHandling;	var		gFinished: boolean;		gHasWNE: boolean;	procedure DoAboutBox;	begin		if alert(rAboutBoxALRT, nil) <> 0 then			;	end;	procedure doAppleMenuChoice (itemNo: integer);		var			itemName: str255;			daDriverRefNum: integer;			oldPort: grafPtr;	begin		case itemNo of			iAbout: 				doAboutBox;			otherwise				begin					GetItem(getMHandle(mApple), itemNo, itemName);					GetPort(oldPort);									{ Work around problems with some VERY old software }					daDriverRefNum := OpenDeskAcc(itemName);					SetPort(oldPort);				end;		end;	end;	procedure DoDumpMenuChoice (itemNo: integer);	begin		case itemNo of			iDumpToData: 				DumpToFiles;			iChangeResourceTypes: 				ChangeToNewResType;			iQuit: 				gFinished := true;		end;	end;	procedure doEditMenuChoice (itemNo: integer);	{ All windows we deal with are either modal dialogs or, under pre-sys 7, desk accessory windows }	begin		if not systemEdit(itemNo - 1) then		{ If it's not handled by a DA ... }			if frontWindow <> nil then				begin					case itemNo of						iUndo: 							sysBeep(0);			{ But then, we never enable this. It's just there for DAs that expect it. }						iCut: 							DialogCut(FrontWindow);						iCopy: 							DialogCopy(FrontWindow);						iPaste: 							DialogPaste(FrontWindow);						iClear: 							DialogDelete(FrontWindow);					end;				end;	end;	procedure DoHighLevelEvent (theEvent: eventRecord);		var			theErr: OSErr;	begin		theErr := AEProcessAppleEvent(theEvent);		if theErr <> noErr then			DoErrorAlert('Could not process an Apple Event that we received!', theErr);	end;{$PUSH}{$Z+}	procedure handleMenuChoice (menuChoice: longint);	begin		if menuChoice <> 0 then			case (HiWord(menuChoice)) of				mApple: 					doAppleMenuChoice(LoWord(menuChoice));				mDump: 					doDumpMenuChoice(LoWord(menuChoice));				mEdit: 					doEditMenuChoice(LoWord(menuChoice));				otherwise					;			end;	end;{$POP}	function eventGetter (eventMask: integer;									var theEvent: EventRecord): boolean;	begin		if gHasWNE then			eventGetter := WaitNextEvent(eventMask, theEvent, 8, nil)		else			begin				eventGetter := GetNextEvent(eventMask, theEvent);				SystemTask;			end;	end;	procedure mainLoop;		var			theEvent: EventRecord;			partCode: integer;			theWindow: WindowPtr;			menuChoice: longint;	begin		repeat			hiliteMenu(0);			if eventGetter(everyEvent, theEvent) then				begin					case theEvent.what of						updateEvt: 							doUpdate(theEvent.message);						keyDown: 							if (BAnd(theEvent.modifiers, cmdKey) <> 0) then								HandleMenuChoice(MenuKey(CHR(BAnd(theEvent.message, charCodeMask))));						mouseDown: 							begin								doAdjustMenus;								partCode := FindWindow(theEvent.where, theWindow);								case partCode of									inSysWindow: 										SystemClick(theEvent, theWindow);									inContent: 										if (theWindow <> FrontWindow) then											SelectWindow(theWindow);									inDrag: 										DragWindow(theWindow, theEvent.where, screenBits.bounds);									inMenuBar: 										begin											menuChoice := MenuSelect(theEvent.where);											if menuChoice <> 0 then												HandleMenuChoice(menuChoice);										end;									diskEvt: 										DoDisk(theEvent.message);									otherwise										;								end;							end;						kHighLevelEvent: 							DoHighLevelEvent(theEvent);						otherwise							;					end;				end;		until gFinished;		;	end;	procedure toolBoxInit;	begin		InitCursor;		FlushEvents(everyEvent, 0);	end;	procedure setupUI;		var			menubarHdl: handle;	begin		menubarHdl := GetNewMBar(rMBarID);		if (menubarHdl <> nil) then			begin				SetMenuBar(menubarHdl);				AddResMenu(GetMHandle(mApple), 'DRVR');				DrawMenuBar;			end;	end;	function DoHandleOpenAppEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;	begin		DoHandleOpenAppEvent := noErr;		{ Why is it again that the OS announces to us that we're running? }	end;	function DoHandleOpenDocEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;		var			theFSS: FSSpec;			docList: AEDescList;			theErr: OSErr;			index, itemsInList: longint;			actualSize: size;			keywd: AEKeyword;			returnedType: DescType;	begin{ First, get the list of files we're being asked to deal with. }		theErr := AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);		if theErr <> noErr then			DoErrorAlert('Unable to decode the Apple Event parameters ', theErr)		else			begin				theErr := AECountItems(docList, itemsInList);				if theErr <> noErr then					DoErrorAlert('Unable to count the number of documents we should deal with', theErr)				else					for index := 1 to itemsInList do						begin							theErr := AEGetNthPtr(doclist, index, typeFSS, keywd, returnedType, @theFSS, sizeof(theFSS), actualsize);							if theErr <> noErr then								DoErrorAlert('Unable to decode a reference to a file', theErr)							else								begin									paramText(theFSS.name, '', '', '');									if alert(rDumpOrReTypeAlert, @StandardFilter) = iDump then										DumpFileToFiles(theFSS)									else										ChangeFileToNewResType(theFSS);								end;						end;				if AEDisposeDesc(docList) <> noErr then					;			end;		DoHandleOpenDocEvent := theErr;	end;	function DoHandlePrintDocEvent (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;	begin		DoErrorAlert('Resource Dumper is unable to print documents!', noErr);		DoHandlePrintDocEvent := noErr;	end;	function DoHandleQuit (theAppleEvent, reply: AppleEvent;									handlerRefcon: longint): OSErr;	begin		gFinished := True;		DoHandleQuit := noErr;	end;	procedure setupAEHandlers;		var			theErr: OSErr;	begin		theErr := AEinstallEventHandler(kCoreEventClass, kAEOpenApplication, @DoHandleOpenAppEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, @DoHandleOpenDocEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, @DoHandlePrintDocEvent, 0, False);		if theErr = noErr then			theErr := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, @DoHandleQuit, 0, False);		if theErr <> noErr then			DoErrorAlert('Unable to set up Apple Event handlers!', theErr);	end;	procedure initProgram;	begin		toolboxInit;		setupUI;		setupAEHandlers;		gFinished := false;		gHasWNE := trapAvailable(_WaitNextEvent);	end;begin	initProgram;{$IFC DEBUGGING}	DisplayInformationalAlert('Setup complete!');{$ENDC}	mainLoop;{$IFC DEBUGGING}	DisplayInformationalAlert('Main loop exited!');{$ENDC}end.