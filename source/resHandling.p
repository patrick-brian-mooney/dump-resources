unit resHandling;interface	uses		script, utils,{}		FSpCompat;	procedure DumpToFiles;	procedure ChangeToNewResType;implementation	function GetResTypeFromDialog (whichDialog: dialogPtr): str255;	{ Doesn't do any validation indicating whether it's a valid OSType: it just returns whatever the field contains }	begin		GetResTypeFromDialog := GetDItemText(whichDialog, iResTypeField);	end;	function GetLowDumpFromDialog (whichDialog: dialogPtr): integer;		var			tempNum: longint;	begin								{ #FIXME: doesn't check to see if the input was acutal numeric }		StringToNum(GetDItemText(whichDialog, iLowestIDField), tempNum);		GetLowDumpFromDialog := tempNum;	end;	function GetHighDumpFromDialog (whichDialog: dialogPtr): integer;		var			tempNum: longint;	begin								{ #FIXME: doesn't check to see if the input was acutal numeric }		StringToNum(GetDItemText(whichDialog, iHighestIDField), tempNum);		GetHighDumpFromDialog := tempNum;	end;	function GetOutputFileTypeFromDialog (whichDialog: dialogPtr): str255;	{ Doesn't do any validation indicating whether it's a valid OSType: it just returns whatever the field contains }	begin		GetOutputFileTypeFromDialog := GetDItemText(whichDialog, iOutputFileTypeField);	end;	function GetOutputFileCreatorFromDialog (whichDialog: dialogPtr): str255;	{ Doesn't do any validation indicating whether it's a valid OSType: it just returns whatever the field contains }	begin		GetOutputFileCreatorFromDialog := GetDItemText(whichDialog, iOutputFileCreatorField);	end;	function IsValidFileDumpParameterDialog (whichDialog: DialogPtr): boolean;	begin		IsValidFileDumpParameterDialog := true;			{ #FIXME !!! }	end;	function ExtractFileDumpParameters (whichDialog: DialogPtr;									var resType: OSType;									var lowDump, highDump: integer;									var outputFType, outputCreator: OSType): OSErr;	begin		resType := GetResTypeFromDialog(whichDialog);		lowDump := GetLowDumpFromDialog(whichDialog);		highDump := GetHighDumpFromDialog(whichDialog);		outputFType := GetOutputFileTypeFromDialog(whichDialog);		outputCreator := GetOutputFileCreatorFromDialog(whichDialog);		ExtractFileDumpParameters := noErr;	end;	function GetFileDumpParameters (whichFile: FSSpec;									var resType: OSType;									var lowDump, highDump: integer;									var outputFType, outputCreator: OSType): OSErr;		var			theDialog: dialogPtr;			oldPort: grafPtr;			valid: boolean;			theItem: integer;	begin		valid := false;		ParamText(whichFile.name, '', '', '');		theDialog := GetNewDialog(rDumpToFilesDLOG, nil, windowPtr(-1));		if theDialog <> nil then			begin				GetPort(oldPort);				SetPort(theDialog);				DrawDefaultButtonOutline(theDialog);				while not valid do					begin						repeat							ModalDialog(nil, theItem);						until (theItem = iOK) or (theItem = iCancel);						if theItem = iCancel then							begin								valid := true;								GetFileDumpParameters := userCanceledErr;							end						else if IsValidFileDumpParameterDialog(theDialog) then							begin								if ExtractFileDumpParameters(theDialog, resType, lowDump, highDump, outputFType, outputCreator) = noErr then									begin										valid := true;										GetFileDumpParameters := noErr;									end;							end;					end;				DisposeDialog(theDialog);				setPort(oldPort);			end		else			;	end;	procedure DumpResourcesToFiles (sourceFile: FSSpec;									whichResType: OSType;									loIDtoDump, hiIDtoDump: integer;									outputFType, outputCreator: OSType);		var			whereToSave, currentDataFile: FSSpec;			resFileRefNum: integer;			err: OSErr;			index, numResources: integer;			continue: boolean;			theResourceHandle: handle;			resourceID: integer;			newDirID: longint;			currentDataFileName: str255;			currentDataFileRefNum: integer;			bytesWritten: longint;			numDumped: integer;	begin		err := SelectSaveLocation('Please choose where to dump the resulting resource file(s)', whereToSave);		if err = noErr then			begin				resFileRefNum := FSpOpenResFileCompat(sourceFile, fsCurPerm);				if resFileRefNum = -1 then					begin						err := resError;						DoErrorAlert('Could not open the file to extract resources!', err);					end			end;		if err = noErr then			begin				numResources := Count1Resources(whichResType);				err := resError;				if err <> noErr then					DoErrorAlert('Unable to count resources of requested type!', err);				if numResources < 1 then					begin						DoErrorAlert('There are no resources of the requested type in the file specified!', ResError);						err := userCanceledErr;					end;			end;		if err = NoErr then			begin				err := FSpDirCreateCompat(whereToSave, smSystemScript, newDirID);				if err <> noErr then					DoErrorAlert('Unable to create directory for target files!', err);			end;		if err = noErr then			begin				continue := true;				index := 1;				numDumped := 0;				while (continue) and (index < (1 + numResources)) do					begin						theResourceHandle := Get1IndResource(whichResType, index);						err := resError;						resourceID := GetResourceID(theResourceHandle);						if (resourceID < loIDtoDump) or (resourceID > hiIDtoDump) then							err := userCanceledErr;						if err = noErr then							begin								HLockHi(theResourceHandle);								err := MemError;								if err <> noErr then									DoErrorAlert('Unable to lock the data in memory!', err);								if err = noErr then									begin										currentDataFileName := concat(whichResType, ' - ', StringFromNum(resourceID));										err := FSMakeFSSpecCompat(whereToSave.vRefNum, newDirID, currentDataFileName, currentDataFile);										if (err <> noErr) and (err <> fnfErr) then											DoErrorAlert('Unable to create a file descriptor for new dump file!', err);										if err = fnfErr then											err := noErr;									end;								if err = noErr then									begin										err := FSpCreateCompat(currentDataFile, outputCreator, outputFType, smSystemScript);										if (err <> noErr) and (err <> fnfErr) then											DoErrorAlert('Unable to create a file description for the data file!', err);									end;								if err = noErr then									begin										err := FSpOpenDF(currentDataFile, fsWrPerm, currentDataFileRefNum);										if err <> noErr then											DoErrorAlert('Unable to open the newly created data file for writing!', err);									end;								if err = noErr then									begin										bytesWritten := GetHandleSize(theResourceHandle);										err := FSWrite(currentDataFileRefNum, bytesWritten, theResourceHandle^);										if err <> noErr then											DoErrorAlert('Unable to write the data to disk!', err);									end;								if err = noErr then									begin										err := FSClose(currentDataFileRefNum);										if err <> noErr then											DoErrorAlert('Unable to close the data file after writing!', err);									end;								if err <> noErr then									begin										continue := false;			{ #FIXME: ask the user whether to continue or not!}									end								else									begin										HUnLock(theResourceHandle);										ReleaseResource(theResourceHandle);										numDumped := numDumped + 1;									end;							end;						index := index + 1;					end;				DisplayInformationalAlert(concat('Dumped ', StringFromNum(numDumped), ' total resource(s)!'));			end;	end;	procedure DumpToFiles;		var			whichFile: FSSpec;			err: OSErr;			whichResType: OSType;			loResIDtoDump, hiResIDtoDump: integer;			outputFType, outputCreator: OSType;	begin		err := SelectFileToDump('', whichFile);		if err = noErr then		{ We will have already reported any errors }			err := GetFileDumpParameters(whichFile, whichResType, loResIDToDump, hiResIDtoDump, outputFType, outputCreator);		if err = noErr then			DumpResourcesToFiles(whichFile, whichResType, loResIDtoDump, hiResIDtoDump, outputFType, outputCreator);	end;	procedure ChangeToNewResType;	begin		DoErrorAlert('This function is not yet implemented.', noErr);	end;end.