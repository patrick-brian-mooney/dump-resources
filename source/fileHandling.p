unit fileHandling;	{ Provides an FSSpec-based interface to the file system, whether or not FSSpec-based routines are actually 	}	{ available on the current system. FSSpecs are just a record type, after all; that is, they are a compiler 		}	{ convention. The data structure can be used to carry information even if the OS version is too old to provide 	}	{ routines to deal with it directly. In that case, these wrapper functions just use the FSSpec record type to 	}	{ carry the information and uses earlier systems calls on the data carried in the records. 	}	{ This unit is part of Resource Dumper, which is copyright © 2018 by Patrick Mooney. program and its source	}	{ code are licensed under the GNU GPL, either version three or (at your option) any later version. See the file	}	{ LICENSE.md for details. 	}interface	uses		utils;	function UnivFSMakeFSSpec (vRefNum: integer;									dirID: longint;									filename: str63;									var spec: FSSpec): OSErr;	function UnivFSpCreate (spec: FSSpec;									creator, fileType: OSType;									scriptTag: scriptCode): OSErr;	procedure UnivFSpCreateResFile (spec: FSSpec;									creator, fileType: OSType;									scriptTag: scriptCode);	function UnivFSpDirCreate (spec: FSSpec;									scriptTag: scriptCode;									var createdDirID: longint): OSErr;	function UnivFSpOpenDF (spec: FSSpec;									permission: signedByte;									var refNum: integer): OSerr;	function UnivFSpOpenResFile (spec: FSSpec;									permission: SignedByte): Integer;implementation{$PUSH}{$Z+}	function UnivFSMakeFSSpec (vRefNum: integer;									dirID: longint;									filename: str63;									var spec: FSSpec): OSErr;		var			ret: OSErr;	begin		if gHasFSSpec then			ret := FSMakeFSSpec(vRefNum, dirID, filename, spec)		else			begin				spec.vRefNum := vRefNum;				spec.parID := dirID;				spec.name := filename;				ret := noErr;			end;		UnivFSMakeFSSpec := ret;	end;{$POP}	function UnivFSpCreate (spec: FSSpec;									creator, fileType: OSType;									scriptTag: scriptCode): OSErr;		var			ret: OSErr;	begin	{#FIXME: do we want to fall back on plain old Create for very early OS versions? }		if gHasFSSpec then			ret := FSpCreate(spec, creator, fileType, scriptTag)		else			ret := HCreate(spec.vRefNum, spec.parID, spec.name, creator, fileType);		UnivFSpCreate := ret;	end;	function UnivFSpDirCreate (spec: FSSpec;									scriptTag: scriptCode;									var createdDirID: longint): OSErr;		var			ret: OSErr;	begin	{#FIXME: is there an even earlier trap to fall back on? Check IM vol. 1	}		if gHasFSSpec then			ret := FSpDirCreate(spec, scriptTag, createdDirID)		else			ret := DirCreate(spec.vRefnum, spec.parID, spec.name, createdDirID);		UnivFSpDirCreate := ret;	end;	procedure UnivFSpCreateResFile (spec: FSSpec;									creator, fileType: OSType;									scriptTag: scriptCode);		var			ret: OSErr;	begin	{#FIXME: fall back on plain old CreateResFile? See IM:MMT 1-57. }	{#FIXME: Resource Manager semantics are kind of fucked up. Refactor to make this return an OSErr. }		if gHasFSSpec then			FSpCreateResFile(spec, creator, fileType, scriptTag)		else			HCreateResFile(spec.vRefNum, spec.parID, spec.name);	end;	function UnivFSpOpenDF (spec: FSSpec;									permission: signedByte;									var refNum: integer): OSerr;		var			ret: OSErr;	begin	{#FIXME: do we want to fall back on even older calls? }		if gHasFSSpec then			ret := FSpOpenDF(spec, permission, refNum)		else			ret := HOpenDF(spec.vRefNum, spec.parID, spec.name, permission, refNum);		UnivFSpOpenDF := ret;	end;	function UnivFSpOpenResFile (spec: FSSpec;									permission: SignedByte): Integer;		var			ret: integer;	begin	{#FIXME: Fall back even further to, say, OpenRFPerm? IM:MMT 1-60ish. }	{#FIXME: Resource Manager semantics are kind of fucked up. Refactor so this returns an OSErr. }		if gHasFSSpec then			ret := FSpOpenResFile(spec, permission)		else			ret := HOpenResFile(spec.vRefNum, spec.parID, spec.name, permission);		UnivFSpOpenResFile := ret;	end;end.