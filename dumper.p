program dumper;{$I-}	uses		balloons, palettes, traps;	const		rMBarID = 128;		mApple = 128;		iAbout = 1;		mDump = 129;		iChangeResourceTypes = 1;		iDumpToData = 2;		iQuit = 4;		mEdit = 130;		iUndo = 1;		iCut = 3;		iCopy = 4;		iPaste = 5;		iSelectAll = 7;		iOK = 1;							{ used by many dialogs }		iCancel = 2;		rAboutBox = 128;		rGenericErrorALRT = 1000;		rUtilityStrings = 1000;		iHelpMenuText = 1;		kExtraStackBytes = 16 * 1024;		kEnter = char(3);		kReturn = char(13);		kEscape = char(27);		kPeriod = '.';	var		gFinished: boolean;		gHasWNE: boolean;		gAppResFile: integer;	function getDItemHandle (theDialog: dialogPtr; itemNo: integer): handle;		var			itemType: integer;			itemHandle: handle;			itemRect: rect;	begin		getDItem(theDialog, itemNo, itemType, itemHandle, itemRect);		getDItemHandle := itemHandle;	end;	function getDItemControlHandle (theDialog: dialogPtr; itemNo: integer): controlHandle;	begin		getDItemControlHandle := controlHandle(GetDItemHandle(theDialog, itemNo));	end;	procedure DoDisk (message: integer);		var			thePoint: Point;			theErr: OSErr;	begin		SetPt(thePoint, 120, 120);		theErr := DIBadMount(thePoint, message);	end;	procedure doUpdate (theWindow: univ windowPtr);			{ any window this app has to update is a dialog window. }		var			oldPort: grafPtr;	begin		if theWindow <> nil then			{ it's unlikely that we'll be passed a null pointer for an updateEvt, but ... }			begin				getPort(oldPort);				setPort(theWindow);				BeginUpdate(theWindow);				if not (EmptyRgn(theWindow^.visRgn)) then					begin						EraseRgn(theWindow^.visRgn);						drawDialog(theWindow);					end;				EndUpdate(theWindow);				setPort(oldPort);			end;	end;	function standardFilter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			charCode: char;			itemType: integer;			itemHandle: Handle;			itemRect: Rect;			finalTicks: longint;			handledEvent: boolean;			thePoint: Point;			theErr: OSErr;			partCode: integer;			theWindow: windowPtr;	begin		handledEvent := false;		case (theEvent.what) of			keyDown, autoKey: 				begin					charCode := chr(BAnd(theEvent.message, charCodeMask));					if ((charCode = char(kReturn)) or (charCode = char(kEnter))) then						begin							GetDItem(theDialog, iOK, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), inButton);							Delay(8, finalTicks);							HiliteControl(ControlHandle(itemHandle), 0);							handledEvent := true;							itemHit := iOK;						end;					if ((charCode = char(kEscape)) or ((BAnd(theEvent.modifiers, cmdKey) <> 0) and (charCode = char(kPeriod)))) then						begin							HiliteControl(getDItemControlHandle(theDialog, iCancel), inButton);							Delay(8, finalTicks);							HiliteControl(getDItemControlHandle(theDialog, iCancel), 0);							handledEvent := true;							itemHit := iCancel;						end;				end;			diskEvt: 				begin					DoDisk(theEvent.message);					handledEvent := true;				end;			updateEvt: 				doUpdate(theEvent.message);			mouseDown: 				begin					partCode := FindWindow(theEvent.where, theWindow);					if theWindow <> theDialog then						sysbeep(1)					else						case partcode of							inDrag: 								begin									DragWindow(theWindow, theEvent.where, screenBits.bounds);									handledEvent := true;								end;							otherwise								;						end;				end;			otherwise				;		end;		standardFilter := handledEvent;	end;	function noCancelButtonFilter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			handled: boolean;			charCode: char;	begin		handled := false;		if (theEvent.what in [keyDown, autoKey]) then			begin				charCode := chr(BAnd(theEvent.message, charCodeMask));				if ((charCode = char(kEscape)) or ((BAnd(theEvent.modifiers, cmdKey) <> 0) and (charCode = char(kPeriod)))) then					handled := true;				{ If the user attempts to "cancel" out of this dialog, intercept it so the OS doesn't do wacky things }			end;		if not handled then			handled := standardFilter(theDialog, theEvent, itemHit);		noCancelButtonFilter := handled;	end;	procedure DoErrorAlert (message: str255);	begin		ParamText(message, '', '', '');		if alert(rGenericErrorALRT, @standardFilter) <> noErr then			;	end;	procedure DoOutlineControl (theControl: univ ControlHandle);		var			theOval: integer;			theRect: Rect;			origPen: PenState;			origPort: grafPtr;	begin		if theControl <> nil then			begin				getPort(origPort);				setPort(theControl^^.contrlOwner);				getPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				insetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = 0) then					PenPat(black)				else					PenPat(gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				setPenState(origPen);				setPort(origPort);			end;	end;	procedure DrawDefaultButtonOutline (theDialog: DialogPtr);		var			theType: integer;			theHand: handle;			therect: rect;	begin		GetDialogItem(theDialog, iOK, theType, theHand, theRect);		DoOutlineControl(theHand);	end;	procedure doAboutBox;		var			theDialog: DialogPtr;			theItem: integer;			oldWindow: WindowPtr;	begin		oldWindow := FrontWindow;		theDialog := GetNewDialog(rAboutBox, @StandardFilter, WindowPtr(-1));		if theDialog <> nil then			begin				SetPort(theDialog);				DrawDefaultButtonOutline(theDialog);				repeat					ModalDialog(nil, theItem);				until theItem = iOK;				DisposeDialog(theDialog);				setPort(oldWindow);			end		else			;	end;	procedure doHelp;	begin	end;	procedure doAppleMenuChoice (itemNo: integer);		var			itemName: str255;			daDriverRefNum: integer;	begin		case itemNo of			iAbout: 				doAboutBox;			otherwise				begin					GetItem(getMHandle(mApple), itemNo, itemName);					daDriverRefNum := OpenDeskAcc(itemName);				end;		end;	end;	procedure DoDumpMenuChoice (itemNo: integer);	begin		case itemNo of			iQuit: 				gFinished := true;			otherwise				sysbeep(0);		end;	end;	procedure handleHelpMenuChoice (itemNo: integer);		var			theHelpMenuHandle: menuHandle;	begin		if noErr = HMGetHelpMenuHandle(theHelpMenuHandle) then			if itemNo = countMItems(theHelpMenuHandle) then				doHelp;	end;	procedure handleMenuChoice (menuChoice: longint);	begin		case (HiWord(menuChoice)) of			mApple: 				doAppleMenuChoice(LoWord(menuChoice));			mDump: 				doDumpMenuChoice(LoWord(menuChoice));			mEdit: 				;			kHMHelpMenuID: 				handleHelpMenuChoice(loWord(menuChoice));			otherwise				;		end;	end;	function eventGetter (eventMask: integer; var theEvent: EventRecord): boolean;	begin		if gHasWNE then			eventGetter := WaitNextEvent(eventMask, theEvent, 8, nil)		else			begin				eventGetter := GetNextEvent(eventMask, theEvent);			end;	end;	procedure mainLoop;		var			theEvent: EventRecord;			partCode: integer;			theWindow: WindowPtr;			menuChoice: longint;	begin		repeat			hiliteMenu(0);			if waitNextEvent(everyEvent, theEvent, 8, nil) then				begin					case theEvent.what of						updateEvt: 							doUpdate(theEvent.message);						keyDown: 							if (BAnd(theEvent.modifiers, cmdKey) <> 0) then								HandleMenuChoice(MenuKey(CHR(BAnd(theEvent.message, charCodeMask))));						mouseDown: 							begin								partCode := FindWindow(theEvent.where, theWindow);								case partCode of									inSysWindow: 										SystemClick(theEvent, theWindow);									inContent: 										if (theWindow <> FrontWindow) then											SelectWindow(theWindow);									inDrag: 										DragWindow(theWindow, theEvent.where, screenBits.bounds);									inMenuBar: 										begin											menuChoice := MenuSelect(theEvent.where);											if menuChoice <> 0 then												HandleMenuChoice(menuChoice);										end;									otherwise										;								end;							end;						diskEvt: 							if theEvent.message <> noErr then								doDisk(theEvent.message);						otherwise							;					end;				end;		until gFinished;		;	end;	procedure increaseStackSize (extraBytes: size);				{ Thx to IM: Memory for this little util. }	begin		setApplLimit(ptr(ord4(getApplLimit) - extraBytes));	end;	procedure toolBoxInit;	begin		InitGraf(@thePort);		moremasters;		moremasters;		moremasters;		moremasters;		InitFonts;		InitWindows;		InitMenus;		TEInit;		InitDialogs(nil);		InitCursor;		FlushEvents(everyEvent, 0);	end;	procedure setupHelpMenu;		var			helpMenuText: str255;			theHelpMenu: menuHandle;	begin		if HMGetHelpMenuHandle(theHelpMenu) = noErr then			begin				getIndString(helpMenuText, rUtilityStrings, iHelpMenuText);				appendMenu(theHelpMenu, helpMenuText);			end;	end;	procedure setupUI;		var			menubarHdl: handle;	begin		menubarHdl := GetNewMBar(rMBarID);		if (menubarHdl <> nil) then			begin				SetMenuBar(menubarHdl);				AddResMenu(GetMHandle(mApple), 'DRVR');				setupHelpMenu;				DrawMenuBar;			end;	end;	function TrapAvailable (theTrap: Integer): Boolean;	{ Thx to the THINK Class Library for this one. }		var			tType: TrapType;			numToolBoxTraps: Integer;	begin		if BAND(theTrap, $0800) > 0 then		{ first determine the trap type }			tType := ToolTrap		else			tType := OSTrap;		{ next find out how may traps there are }		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			numToolBoxTraps := $200		else			numToolBoxTraps := $400;		if tType = ToolTrap then 		{ check if trap number is too big for current trap table }			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= numToolBoxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := (NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap));	end;	procedure initProgram;	begin		increaseStackSize(kExtraStackBytes);		maxApplZone;		toolboxInit;		setupUI;		randSeed := tickCount;		gAppResFile := curResFile;		gFinished := false;		gHasWNE := trapAvailable(_WaitNextEvent);	end;begin	initProgram;	mainLoop;	exitToShell;end.